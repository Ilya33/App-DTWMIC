#!/usr/bin/perl

use strict;
use warnings;

use utf8;

use App::DTWMIC;

use List::Util qw(max);
use Getopt::Long;

use Data::Dumper;

use Udev::FFI;
#use Gtk3 '-init';


use constant {
    DEVICE_INPUT_OTHER          => 0,
    DEVICE_INPUT_MOUSE          => 1,
    DEVICE_INPUT_TOUCHPAD       => 2,
    DEVICE_INPUT_TABLET         => 3,
    DEVICE_INPUT_TOUCHSCREEN    => 4
};



sub _get_device_type {
    my $device = shift;

    my $id_input_mouse          = $device->get_property_value('ID_INPUT_MOUSE');
    my $id_input_touchpad       = $device->get_property_value('ID_INPUT_TOUCHPAD');
    my $id_input_tablet         = $device->get_property_value('ID_INPUT_TABLET');
    my $id_input_touchscreen    = $device->get_property_value('ID_INPUT_TOUCHSCREEN');

    if (defined($id_input_mouse) && $id_input_mouse eq '1') {
        # ID_INPUT_MOUSE: Touchscreens and tablets have this flag as
        # well, since by the type of events they can produce they act as
        # a mouse.
        # https://askubuntu.com/questions/520359/how-to-detect-touchscreen-devices-from-a-script

        if (defined($id_input_touchpad) && $id_input_touchpad eq '1') {
            return DEVICE_INPUT_TOUCHPAD;
        }
        elsif (defined($id_input_tablet) && $id_input_tablet eq '1') {
            return DEVICE_INPUT_TABLET;
        }
        elsif (defined($id_input_touchscreen) && $id_input_touchscreen eq '1') {
            return DEVICE_INPUT_TOUCHSCREEN;
        }

        return DEVICE_INPUT_MOUSE;
    }
    elsif (defined($id_input_touchpad) && $id_input_touchpad eq '1') {
        return DEVICE_INPUT_TOUCHPAD;
    }
    elsif (defined($id_input_tablet) && $id_input_tablet eq '1') {
        return DEVICE_INPUT_TABLET;
    }
    elsif (defined($id_input_touchscreen) && $id_input_touchscreen eq '1') {
        return DEVICE_INPUT_TOUCHSCREEN;
    }


    return DEVICE_INPUT_OTHER;
}



my $help;
my $list;
my $config_path;
#my $has_gui;

GetOptions(
    'h|help' => \$help,
    'l|list' => \$list,
    'f|config-file=s' => \$config_path,
#    'c|configure' => \$has_gui
)
or die("Error in command line arguments\n");


my $udev = Udev::FFI->new() or
    die("Can't initialize Udev::FFI library: $@");

my $enumerate = $udev->new_enumerate() or
    die("Can't create enumerate context: $@");

$enumerate->add_match_subsystem('input') or
    die("Can't add match subsystem: $!");


if (defined($list)) {
    $enumerate->scan_devices() or
        die("Can't scan devices: $!");

    my $devices = $enumerate->get_list_entries() or
        die "Can't get devices: $!";

    my $mouse_devices = {};
    my $touchpads = {};
    my $tablets = {};
    my @lengths;

    for (keys(%$devices)) {
        if (defined(my $device = $udev->new_device_from_syspath($_))) {
            my $parent = $device->get_parent_with_subsystem_devtype('input');

            next
                unless defined $parent;

            my $device_type = _get_device_type($device);
            my $name = $parent->get_property_value('NAME');
            $name = 'unknown'
                unless defined $name;

            my $p_devices;
            if (DEVICE_INPUT_MOUSE == $device_type) {
                $p_devices = $mouse_devices;
            }
            elsif (DEVICE_INPUT_TOUCHPAD == $device_type) {
                $p_devices = $touchpads;
            }
            elsif (DEVICE_INPUT_TABLET == $device_type) {
                $p_devices = $tablets;
            }
            else {
                next;
            }


            $p_devices->{ $parent->get_sysname() } = {
                name => $name
            };

            push(@lengths, length($name));
        }
    }


    my $max_str_length = max(@lengths) + 8;
    $max_str_length -= ($max_str_length % 4);

    print "MOUSE DEVICES:\n";
    for (keys(%$mouse_devices)) {
        print '  '.$mouse_devices->{$_}{name}.(' ' x ($max_str_length - length($mouse_devices->{$_}{name}))).'sysname: '.$_."\n";
    }

    print "TOUCHPAD DEVICES:\n";
    for (keys(%$touchpads)) {
        print '  '.$touchpads->{$_}{name}.(' ' x ($max_str_length - length($touchpads->{$_}{name}))).'sysname: '.$_."\n";
    }


    exit(0);
}


my $monitor = $udev->new_monitor() or
    die "Can't create udev monitor: $@";

$monitor->filter_by_subsystem_devtype('input') or
    die "Can't add filter to udev monitor: $!";

$monitor->start() or
    die "Can't start udev monitor: $!";


$enumerate->scan_devices() or
    die("Can't scan devices: $!");

my $devices = $enumerate->get_list_entries() or
    die "Can't get devices: $!";

for(keys(%$devices)) {
    if (defined(my $device = $udev->new_device_from_syspath($_))) {
        #my $device = $monitor->poll(); #blocking read
        #my $action = $device->get_action();


        #warn Dumper $device->get_sysattr_list_entries();
        warn Dumper $device->get_properties_list_entries();
        if ($device->get_property_value('ID_INPUT_MOUSE')) {
            print 'SYSNAME: '.$device->get_sysname(), "\n";
            print 'DEVNODE: '.$device->get_devnode(), "\n";
            print "----------------------------\n";
        }
    }
}